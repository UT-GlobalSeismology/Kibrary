/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package io.github.kensuke1984.anisotime;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.FutureTask;
import java.util.stream.Collectors;

import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;

/**
 * 
 * GUI for ANISOtime
 * 
 * @version 0.5
 * 
 * @author Kensuke Konishi
 */
class ANISOtimeGUI extends javax.swing.JFrame {

	private static final long serialVersionUID = -4093263118460123169L;

	/**
	 * Creates new form TravelTimeGUI
	 */
	ANISOtimeGUI() {
		initComponents();
	}

	private RaypathWindow raypathWindow;

	int getNumberOfRaypath() {
		return resultWindow.getN();
	}

	void selectRaypath(int i) {
		raypathWindow.selectPath(i);
	}

	void setRaypathVisible(boolean bool) {
		raypathWindow.setVisible(bool);
	}

	void addPath(double[] x, double[] y) {
		raypathWindow.addPath(x, y);
	}

	void createNewRaypathTabs() {
		if (raypathWindow != null)
			raypathWindow.dispose();
		raypathWindow = new RaypathWindow(this, new RaypathPanel(jPanelParameter.getStructure()));
		resultWindow.clearRows();
	}

	VelocityStructure getStructure() {
		return jPanelParameter.getStructure();
	}

	double getEventR() {
		return jPanelParameter.getEventR();
	}

	/**
	 * @return Epicentral Distance mode: epicentral distance[deg]<br>
	 *         Ray parameter mode: ray parameter<br>
	 */
	double getMostImportant() {
		return jPanelParameter.getMostImportant();
	}

	/**
	 * @return 0(default): All, 1: P-SV, 2: SH
	 */
	synchronized int getPolarity() {
		return jMenuBar1.getPolarity();
	}

	void setMode(ComputationMode mode) {
		jPanelParameter.changeBorderTitle(jMenuBar1.getModeName() + "  " + jMenuBar1.getPoleString());
		jPanelParameter.setMode(mode);
	}

	void changePropertiesVisible() {
		jPanelParameter.changePropertiesVisible();
	}

	synchronized void setPolarity(int i) {
		phaseWindow.setPolarity(i);
		jMenuBar1.setPolarity(i);
		jPanelParameter.changeBorderTitle(jMenuBar1.getModeName() + " " + jMenuBar1.getPoleString());
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initComponents() {
		setTitle("ANISOtime " + ANISOtime.version + " " + ANISOtime.codename);
		setLocationRelativeTo(null);
		phaseWindow = new PhaseWindow();
		resultWindow = new ResultWindow(this);

		jPanelParameter = new ParameterInputPanel();
		// jPanelTurningInformation = new TurningInformationPanel();
		// jPanelPhase = new PhasePanel();
		buttonCompute = new JButton("Compute");
		buttonShow = new JButton("Save");
		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

		// jMenuItem1 = new JMenuItem();
		jMenuBar1 = new MenuBar(this);
		setJMenuBar(jMenuBar1);
		// textFieldRayParameter.setText("0");

		buttonCompute.addActionListener(this::buttonComputeActionPerformed);

		buttonShow.addActionListener(this::buttonSavePerformed);

		GroupLayout layout = new GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(layout.createSequentialGroup()
				.addContainerGap()
				.addGroup(layout.createParallelGroup(Alignment.CENTER).addGroup(layout.createSequentialGroup()
						.addGroup(layout.createParallelGroup(Alignment.LEADING).addGroup(layout.createSequentialGroup())
								.addComponent(jPanelParameter, GroupLayout.PREFERRED_SIZE, 300, Short.MAX_VALUE)))
						.addGroup(layout.createSequentialGroup().addGroup(
								layout.createSequentialGroup().addComponent(buttonCompute).addComponent(buttonShow)))
						.addComponent(resultWindow))
				.addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(Alignment.LEADING)
				.addGroup(layout.createSequentialGroup().addContainerGap()
						.addComponent(jPanelParameter, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE,
								GroupLayout.PREFERRED_SIZE)
						.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
								.addComponent(buttonCompute).addComponent(buttonShow))
						.addComponent(resultWindow, 100, 100, 100).addContainerGap()));

		pack();
		setPolarity(0);
		setLocation(getX() - getWidth() / 2, getY() - getHeight() / 2);
		phaseWindow.setLocation(getX() + getWidth(), getY());
		phaseWindow.setVisible(true);
		setMode(jMenuBar1.selectedMode());
	}// </editor-fold>//GEN-END:initComponents

	/**
	 * @return phases selected at the time considering polarity. When S is
	 *         checked and polarity is ALL, then SH and SV return.
	 */
	synchronized Set<Phase> getSelectedPhaseSet() {
		Set<Phase> phaseSet = phaseWindow.getSelectedPhaseSet();
		switch (getPolarity()) {
		case 0:
			Set<Phase> allSet = new HashSet<>(phaseSet);
			allSet.addAll(phaseSet.stream().map(p -> Phase.create(p.toString(), true)).filter(Phase::isPSV)
					.collect(Collectors.toSet()));
			return allSet;
		case 1:
			return phaseSet.stream().map(p -> Phase.create(p.toString(), true)).filter(Phase::isPSV)
					.collect(Collectors.toSet());
		case 2:
			return phaseSet.stream().filter(p -> !p.isPSV()).collect(Collectors.toSet());
		default:
			throw new RuntimeException("anekusupekutedo");
		}
	}

	/**
	 * when the button "Save" is clicked.
	 */
	private void buttonSavePerformed(java.awt.event.ActionEvent evt) {
		double eventR = getEventR();

		FutureTask<Path> askOutPath = new FutureTask<>(() -> {
			JFileChooser fileChooser = new JFileChooser(System.getProperty("user.dir"));
			fileChooser.setDialogTitle("Output the path?");
			fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
			int action = fileChooser.showOpenDialog(null);
			if (action == JFileChooser.CANCEL_OPTION || action == JFileChooser.ERROR_OPTION)
				return null;
			return fileChooser.getSelectedFile().toPath();
		});

		SwingUtilities.invokeLater(askOutPath);

		Runnable output = () -> {

			List<Raypath> raypathList;
			List<Phase> phaseList;
			Path outputDirectory;
			switch (selectedMode()) {
			case EPICENTRAL_DISTANCE:
				raypathList = new ArrayList<>();
				phaseList = new ArrayList<>();
				RaypathCatalog catalog = RaypathCatalog.computeCatalogue(getStructure(),
						ComputationalMesh.simple(getStructure()), Math.toRadians(1));
				double epicentralDistance = Math.toRadians(getMostImportant());
				for (Phase phase : getSelectedPhaseSet()) {
					Raypath[] raypaths = catalog.searchPath(phase, eventR, epicentralDistance);
					if (raypaths.length == 0)
						continue;
					for (int i = 0; i < raypaths.length; i++) {
						raypathList.add(raypaths[i]);
						phaseList.add(phase);
					}
				}
				for (int i = 0; i < phaseList.size(); i++) {
					Phase phase = phaseList.get(i);
					if (!phase.isDiffracted())
						continue;
					Raypath raypath = raypathList.get(i);
					double delta = raypath.computeDelta(eventR, phase);
					double dDelta = Math.toDegrees(epicentralDistance - delta);
					phaseList.set(i, Phase.create(phase.toString() + dDelta));
				}

				break;
			case RAYPARAMETER:
				raypathList = new ArrayList<>();
				phaseList = new ArrayList<>(getSelectedPhaseSet());
				Raypath raypath = new Raypath(getMostImportant(), getStructure());
				raypath.compute();
				for (int i = 0; i < phaseList.size(); i++)
					raypathList.add(raypath);
				break;
			default:
				throw new RuntimeException("unekuspekudte");
			}

			try {
				outputDirectory = askOutPath.get();
				if (outputDirectory == null)
					return;
				if (raypathList.size() != phaseList.size())
					throw new RuntimeException("UNEXPECTED");
				for (int i = 0; i < raypathList.size(); i++) {
					String name = phaseList.get(i).isPSV() ? phaseList.get(i) + "_PSV" : phaseList.get(i) + "_SH";
					Path outEPSFile = outputDirectory.resolve(name + ".eps");
					Path outInfoFile = outputDirectory.resolve(name + ".inf");
					Path outDataFile = outputDirectory.resolve(name + ".dat");
					raypathList.get(i).outputEPS(eventR, phaseList.get(i), outEPSFile);
					raypathList.get(i).outputInfo(outInfoFile, eventR, phaseList.get(i));
					raypathList.get(i).outputDat(outDataFile, eventR, phaseList.get(i));
				}
			} catch (Exception e) {
				e.printStackTrace();
				SwingUtilities
						.invokeLater(() -> JOptionPane.showMessageDialog(null, "Cannot output files about the path"));
			}
		};
		new Thread(output).start();

	}

	/**
	 * when the button "Compute" is clicked.
	 */
	private void buttonComputeActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_buttonComputeActionPerformed
		createNewRaypathTabs();
		switch (selectedMode()) {
		case EPICENTRAL_DISTANCE:
			new Thread(this::runEpicentralDistanceMode).start();
			break;
		case RAYPARAMETER:
			new Thread(this::runRayParameterMode).start();
			break;
		}
	}// GEN-LAST:event_buttonComputeActionPerformed

	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void main(String args[]) {
		try {
			for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
				if ("Nimbus".equals(info.getName())) {
					javax.swing.UIManager.setLookAndFeel(info.getClassName());
					break;
				}
			}
		} catch (ClassNotFoundException ex) {
			java.util.logging.Logger.getLogger(ANISOtimeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null,
					ex);
		} catch (InstantiationException ex) {
			java.util.logging.Logger.getLogger(ANISOtimeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null,
					ex);
		} catch (IllegalAccessException ex) {
			java.util.logging.Logger.getLogger(ANISOtimeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null,
					ex);
		} catch (javax.swing.UnsupportedLookAndFeelException ex) {
			java.util.logging.Logger.getLogger(ANISOtimeGUI.class.getName()).log(java.util.logging.Level.SEVERE, null,
					ex);
		}
		// </editor-fold>

		/* Create and display the form */
		java.awt.EventQueue.invokeLater(() -> new ANISOtimeGUI().setVisible(true));
	}

	void setResult(int i) {
		resultWindow.setColor(i);
	}

	ComputationMode selectedMode() {
		return jMenuBar1.selectedMode();
	}

	void addResult(double epicentralDistance, double depth, String phase, double travelTime, double rayparameter) {
		resultWindow.addRow(epicentralDistance, depth, phase, travelTime, rayparameter);
	}

	public void runRayParameterMode() {
		Raypath raypath = new Raypath(getMostImportant(), getStructure());
		raypath.compute();
		List<Raypath> raypaths = new ArrayList<>();
		List<Phase> phases = new ArrayList<>(getSelectedPhaseSet());

		for (int i = 0; i < phases.size(); i++)
			raypaths.add(raypath);

		showResult(null, raypaths, phases);
	}

	public void runEpicentralDistanceMode() {
		RaypathCatalog catalog = RaypathCatalog.computeCatalogue(getStructure(),
				ComputationalMesh.simple(getStructure()), Math.toRadians(1));
		List<Raypath> raypathList = new ArrayList<>();
		List<Phase> phaseList = new ArrayList<>();
		double eventR = getEventR();
		double epicentralDistance = Math.toRadians(getMostImportant());
		for (Phase phase : getSelectedPhaseSet()) {
			Raypath[] raypaths = catalog.searchPath(phase, eventR, epicentralDistance);
			if (raypaths.length == 0)
				continue;
			for (int i = 0; i < raypaths.length; i++) {
				raypathList.add(raypaths[i]);
				phaseList.add(phase);
			}

		}
		for (int i = 0; i < phaseList.size(); i++) {
			Phase phase = phaseList.get(i);
			if (!phase.isDiffracted())
				continue;
			Raypath raypath = raypathList.get(i);
			double delta = raypath.computeDelta(eventR, phase);
			double dDelta = Math.toDegrees(epicentralDistance - delta);
			phaseList.set(i, Phase.create(phase.toString() + dDelta));
		}
		int n = raypathList.size();
		// System.out.println("Whats done is done");
		double[] delta = new double[n];
		Arrays.fill(delta, epicentralDistance);
		showResult(delta, raypathList, phaseList);
	}

	/**
	 * This method shows results containing i th phase of i th raypath
	 * 
	 * @param delta
	 *            Array of epicentral distance
	 * @param raypathList
	 *            List of {@link Raypath}
	 * @param phaseList
	 *            List of {@link Phase}
	 */
	synchronized public void showResult(final double[] delta, final List<Raypath> raypathList,
			final List<Phase> phaseList) {
		Objects.requireNonNull(raypathList);
		Objects.requireNonNull(phaseList);
		if (raypathList.size() != phaseList.size())
			throw new RuntimeException("UNEXPECTED");
		// System.out.println(SwingUtilities.isEventDispatchThread());
		double eventR = getEventR();
		for (int i = 0; i < phaseList.size(); i++) {
			Raypath raypath = raypathList.get(i);
			Phase phase = phaseList.get(i);
			if (!raypath.exists(eventR, phase))
				continue;
			// travelTimeTool.addPanels(panel);
			double epicentralDistance = Math.toDegrees(raypath.computeDelta(eventR, phase));
			double travelTime = raypath.computeT(eventR, phase);
			// System.out.println(epicentralDistance+" "+travelTime);
			String title = phase.isPSV() ? phase + " (P-SV)" : phase + " (SH)";
			double depth = raypath.earthRadius() - getEventR();

			if (delta == null) {
				addResult(epicentralDistance, depth, title, travelTime, raypath.getRayParameter());
				showRayPath(this, raypath, phase);
			} else {
				double time = travelTime;
				double interval = 0.1;
				double targetDelta = Math.toDegrees(delta[i]);
				if (!phase.isDiffracted())
					try {
						while ((time = RaypathCatalog.travelTimeByThreePointInterpolate(targetDelta, raypath,
								getEventR(), phase, interval)) < 0)
							interval *= 10;
					} catch (Exception e) {
						// e.printStackTrace();
						addResult(epicentralDistance, depth, title, travelTime, raypath.getRayParameter());
						showRayPath(this, raypath, phase);
						continue;
					}
				if (!Double.isNaN(time)) {
					addResult(targetDelta, depth, title, time, raypath.getRayParameter());
					showRayPath(this, raypath, phase);
				}
			}
		}
		try {
			if (0 < getNumberOfRaypath())
				SwingUtilities.invokeLater(() -> {
					setRaypathVisible(true);
					setResult(0);
					selectRaypath(0);
				});
		} catch (Exception e) {
		}

	}

	private static void showRayPath(ANISOtimeGUI travelTimeGUI, Raypath raypath, Phase phase) {
		if (!raypath.exists(travelTimeGUI.getEventR(), phase))
			return;
		double[][] points = raypath.getRouteXY(travelTimeGUI.getEventR(), phase);
		if (points != null) {
			double[] x = new double[points.length];
			double[] y = new double[points.length];
			for (int i = 0; i < points.length; i++) {
				x[i] = points[i][0];
				y[i] = points[i][1];
			}
			try {
				SwingUtilities.invokeAndWait(() -> travelTimeGUI.addPath(x, y));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return;
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private JButton buttonCompute;
	private JButton buttonShow;
	private MenuBar jMenuBar1;
	private ParameterInputPanel jPanelParameter;
	private ResultWindow resultWindow;
	private PhaseWindow phaseWindow;
	// End of variables declaration//GEN-END:variables
}
